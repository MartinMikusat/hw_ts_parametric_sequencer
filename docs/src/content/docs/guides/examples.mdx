---
title: Examples
description: Code examples and integration patterns
---

## Three.js Integration

```typescript
import { reconcileScene, reconcile_animationState, NodeMain, Vector3, Euler, SceneObject } from 'hw-ts-parametric-sequencer/3d';
import * as THREE from 'three';

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();

// Create a mesh
const geometry = new THREE.BoxGeometry();
const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
const mesh = new THREE.Mesh(geometry, material);
scene.add(mesh);

// Create scene object
const object = new SceneObject('box1', {});

// Define animation
const animationScene = [
  new NodeMain({
    name: 'rotate-box',
    chapter: 'intro',
    sceneObject: object,
    time: { type: 'absolute', value: 0 },
    duration: 2,
    rotation: { type: 'relative', value: new Euler(0, Math.PI, 0) }
  })
];

// Reconcile the scene once
const reconciled = reconcileScene(animationScene);

// Animation loop
let startTime = Date.now();
function animate() {
  requestAnimationFrame(animate);
  
  const currentTime = (Date.now() - startTime) / 1000;
  const state = reconcile_animationState(reconciled, currentTime);
  
  const modelState = state.models.get('box1');
  if (modelState) {
    // Update mesh position
    mesh.position.set(
      modelState.position.x,
      modelState.position.y,
      modelState.position.z
    );
    
    // Update mesh rotation (convert quaternion to Three.js)
    mesh.quaternion.set(
      modelState.rotation.x,
      modelState.rotation.y,
      modelState.rotation.z,
      modelState.rotation.w
    );
    
    // Update material opacity
    material.opacity = modelState.opacity;
    material.transparent = modelState.opacity < 1;
  }
  
  // Update camera
  camera.position.set(
    state.camera.target.x,
    state.camera.target.y + 5,
    state.camera.target.z + 10
  );
  camera.lookAt(state.camera.target.x, state.camera.target.y, state.camera.target.z);
  
  renderer.render(scene, camera);
}
animate();
```

## Canvas 2D Integration

```typescript
import { reconcileScene2D, reconcile_animationState2D, NodeMain2D, Vector2, SceneObject2D } from 'hw-ts-parametric-sequencer/2d';

const canvas = document.getElementById('canvas') as HTMLCanvasElement;
const ctx = canvas.getContext('2d')!;

const object = new SceneObject2D('sprite1', {});

const scene = [
  new NodeMain2D({
    name: 'move-sprite',
    chapter: 'intro',
    sceneObject: object,
    time: { type: 'absolute', value: 0 },
    duration: 2,
    position: { type: 'absolute', value: new Vector2(100, 50) },
    rotation: { type: 'relative', value: 90 },
    opacity: 1.0,
    scale: 1.5
  })
];

// Reconcile the scene once
const reconciled = reconcileScene2D(scene);

// Animation loop
let startTime = Date.now();
function animate() {
  requestAnimationFrame(animate);
  
  const currentTime = (Date.now() - startTime) / 1000;
  const state = reconcile_animationState2D(reconciled, currentTime);
  
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  state.models.forEach((modelState, modelID) => {
    ctx.save();
    
    // Apply transformations
    ctx.translate(modelState.position.x, modelState.position.y);
    ctx.rotate(modelState.rotation * Math.PI / 180);
    ctx.scale(modelState.scale, modelState.scale);
    ctx.globalAlpha = modelState.opacity;
    
    // Draw your sprite
    ctx.fillStyle = '#00ff00';
    ctx.fillRect(-10, -10, 20, 20);
    
    ctx.restore();
  });
}
animate();
```

## React Integration

```typescript
import { useEffect, useRef, useState } from 'react';
import { reconcileScene, reconcile_animationState, NodeMain, Vector3, SceneObject } from 'hw-ts-parametric-sequencer/3d';

function AnimatedScene() {
  const [animationState, setAnimationState] = useState<any>(null);
  const startTimeRef = useRef<number>(Date.now());
  const reconciledRef = useRef<any>(null);
  
  useEffect(() => {
    const object = new SceneObject('object1', {});
    
    const scene = [
      new NodeMain({
        name: 'animate',
        chapter: 'intro',
        sceneObject: object,
        time: { type: 'absolute', value: 0 },
        duration: 2,
        position: { type: 'absolute', value: new Vector3(1, 0, 0) }
      })
    ];
    
    // Reconcile once
    reconciledRef.current = reconcileScene(scene);
    startTimeRef.current = Date.now();
    
    // Animation loop
    function animate() {
      const currentTime = (Date.now() - startTimeRef.current) / 1000;
      const state = reconcile_animationState(reconciledRef.current, currentTime);
      setAnimationState(state);
      requestAnimationFrame(animate);
    }
    
    const animationId = requestAnimationFrame(animate);
    
    return () => {
      cancelAnimationFrame(animationId);
    };
  }, []);
  
  return <div>Your scene here</div>;
}
```

## Complex Timing Dependencies

```typescript
// Animation 1: Move object
const moveNode = new NodeMain({
  name: 'move-object',
  chapter: 'intro',
  sceneObject: object,
  time: { type: 'absolute', value: 0 },
  duration: 2,
  position: { type: 'absolute', value: new Vector3(1, 0, 0) }
});

// Animation 2: Start camera 0.5s after move starts
const cameraNode = new NodeCamera({
  name: 'camera-follow',
  chapter: 'intro',
  time: {
    type: 'relative',
    value: {
      offset: 0.5,
      side: 'Start',
      parentID: 'move-object'
    }
  },
  duration: 1.5,
  rotationX: 45,
  rotationY: -30,
  target: new Vector3(0, 0, 0),
  zoom: 1.2
});

// Animation 3: Start fade-out 0.3s before move ends
const fadeNode = new NodeBasicHide({
  name: 'fade-out',
  chapter: 'outro',
  sceneObject: object,
  time: {
    type: 'relative',
    value: {
      offset: -0.3,
      side: 'End',
      parentID: 'move-object'
    }
  },
  duration: 1
});

const scene = [moveNode, cameraNode, fadeNode];
```

